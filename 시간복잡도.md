시간복잡도

다익스트라 알고리즘은 변 경감(edge relaxation)이라고 불리는 연산을 기본 바탕으로 하고 있다. 정점 a에서 정점 b까지의 최단 거리를 이미 알고 있고, b에서 c까지의 거리를 알고 있다면 a에서 c까지의 최단 거리는 a에서 b까지의 거리에 b에서 c까지의 거리를 더해서 구하는 방식이다.  

다익스트라 알고리즘을 코드로 구현할 때에 이 변 경감이라는 것이 기본이 되지만, 이 알고리즘을 짜는 데에 대한 변형 로직은 당연히 여럿 존재한다.
방법으로 대략 한 정점에 대하여 연결된 모든 간선의 가중치를 모두 비교하는 방법과, 가중치를 오름차순 등으로 정렬하여 가중치가 적은 간선을 먼저 가져오는 방법 두 가지가 있는 것 같다. 전자는 배열 등으로 단순하게 구현되는 반면, 후자는 우선순위 큐와 같은 자료 구조를 통한 처리를 동반한다.

이 두 방법을 서로 비교해보고 싶어서 시간복잡도를 계산하여 어떤 방법이 더 효율적인지 계산해 보았다. 그런데 그 전에 먼저  어떤 방법이 더 효율적일지 예측해보았는데, 결과는 예상과 동일했지만 생각과는 조금 다른 점이 있었다.

모든 가중치를 비교하는 방법
![일반](https://user-images.githubusercontent.com/80510925/113894051-99a4c100-9802-11eb-9af1-59d4559eb7a8.PNG)

우선순위 큐를 이용한 방법
![우선순위 큐](https://user-images.githubusercontent.com/80510925/113894200-b8a35300-9802-11eb-892f-7a2cd05905d1.PNG)

결과로는 당연히 우선순위 큐를 이용하여 가중치가 더 적은 간선을 먼저 가져오는 방법이 더 빠른 속도를 가질 것이라고 생각했다.  가장 적은 가중치를 가진 간선 하나를 가져오는 것에 비해 한 정점을 기준으로 다른 정점까지의 모든 간선의 가중치를 비교하는 것은 효율이 더 좋지 않기 때문이다. 하지만 우선순위 큐 자체를 구현하기 위해 코드 줄 수가 더 사용되었고 그에 따라 시간을 더 잡아먹는 점도 생각해야 하기에 단순히 시간복잡도로 계산하는 것이 의미가 있는지 알아야 했다.

그런데 시간복잡도를 가지고 두 방법의 정점과 시간에 관한 그래프를 그려보자 우선순위 큐를 사용한 방법이 다익스트라 알고리즘을 수행하는 데에는 너무나 압도적인 효율을 가진다는 것을 알 수 있어 가중치를 정렬하는데 드는 시간을 고려할 필요가 없다는 결론이 나왔다.

시간복잡도는 V는 정점 수, E는 간선 수 라고 할 때 모든 가중치를 비교하는 방법은 O(V^2), 우선순위 큐를 이용한 방법은 O(ElogV) 의 시간 복잡도를 가졌다. 이 때 우리가 코드를 실행해 볼 때 사용한 임의의 간선 수를 가져와서 간선 수를 9로 놓고 그래프를 그려보았다.

![1](https://user-images.githubusercontent.com/80510925/113893913-6feb9a00-9802-11eb-8057-86ec3ecb3d3b.PNG)

![2](https://user-images.githubusercontent.com/80510925/113893994-8b56a500-9802-11eb-80db-cd867f355553.PNG)심지어 정점과 가중치가 적은 경우에도 다익스트라 알고리즘을 수행하는 데에는 우선순위 큐가 더 유효하다는 결과가 나와서 이런 경우 정렬을 하기 위한 시간을 추가해도 정점과 가중치가 적으므로 성능에 큰 차이를 보이지 않을 것으로 보인다.

